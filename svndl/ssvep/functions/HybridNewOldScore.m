function [thresh,slope,range]=HybridNewOldScore( tSweepMat, varargin )% Take a 2-D matrix that is NSteps x 5 sweep stats (see SweepMat.m)% and compute estimates of threshold and slope obtained by linear regression% over the range of bins determined by the PowerDIVA scoring algorithm.% tSweepMat, e.g., obtained by call to SweepMat( RLSMat ) functions,% should be sorted to have increasing visibility. It is caller's% responsibility to ensure that tStart and tEnd result in correct logic% for computing thresholds.% Command line usage for debugging would be something like% HybridNewOldScore( SweepMat( RLSMat ), tStart, tEnd, tLinLog, tLSB, tRSB )tSweepMat = num2cell( tSweepMat, 1 );[ sig,noise,phase,snr,pval ] = deal( tSweepMat{:} );bin = [ 1:length( sig ) ]'; % Like PD, this function will regress against bin indices,							% and then transform to stimulus values...n=size(sig,1);range = [ NaN NaN ];thresh = NaN;slope = NaN;crit=[ 0.3, 0.16, 0.077, 0.005, -100, 80, 3.0, 1.5 ];% readable symbols for indexing crit vector.iSpk	= 1;iPLo	= 2;iP		= 3;iPHi	= 4;iPhLo	= 5;iPhHi	= 6;iSNR30	= 7;iSNR15	= 8;dp=diff(phase);k=dp> 180;	dp(k)=dp(k)-360;k=dp<-180;	dp(k)=dp(k)+360;% tests (0)fail, (1)passtests=zeros(n,10);				% not 3x prev bin				% not 3x next bintests(:,1)=[ 1; sig(1:n-1)>crit(iSpk)*sig(2:n) ] |[ sig(2:n)>crit(iSpk)*sig(1:n-1); 1 ]; % not spiketests(:,2)=pval<crit(iPLo);											% weak criterion for finding first and range pointstests(:,3)= [ 0; pval(1:n-1)<crit(iP) & pval(2:n)<crit(iP) ];		% strong criterion for scoring, consecutive binstests(:,4)=noise<.7*sig;										% not used -- kept for place holder; noise; more like local snr.% tests(:,5)=[1;(dp>crit(iPhLo) & dp<crit(iPhHi)) | pval(2:n)<crit(iPHi)];	% phasetTestPh = [1;(dp>crit(iPhLo) & dp<crit(iPhHi)) ];tTestPh( 1 ) = tTestPh( 2 ); % bin 1 should never be tested for dPh, but we make it have the most sensible value anywaytests(:,5)=tTestPh;	% phase; ditch strict PVal alternativetests(:,6)=[1;sig(2:n)>sig(1:n-1)];								% montonic, gt prev bintests(:,10)=snr>crit( iSNR15 );										% SNR 1.5 for range elegibilty% tests(:,7)=all(tests(:,1:2),2);								% first pt (snr, not spike, noise)tests(:,7)= ( tests(:,2) | tests(:,10) ) & tests(:,1) & tests(:,4);	% first pt (pweak|snr15, not spike, noise)tests(:,8)=tests(:,7) & tests(:,5);								% range pt (snr, not spike, noise, phase)tests(:,9)=snr>crit( iSNR30 );										% strong SNR criterion for scoring, single binif nargin == 1 % unknown score bounds, use full PD scoring algorithm	ki=1;	while ki~=n		ki=findFirstPoint(ki,n,tests); % first point ( snr, not spike, noise ) followed by range point( snr, not spike, noise, phase )		if isnan(ki)			break		end		kf=findRangeExtent(ki,n,tests); % last in series of range points		kf=forceMonotonic(ki,kf,tests); % if necessary, change to last bin where sig g.t. prev bin		if testInitialRange(ki,kf,tests) % last bin pval (and, if only two range bins, first pval)			ki=addRange(ki,tests); % decrement first bin if phase and monotonic			if ki~=kf				k=ki:kf;				y=sig(k);				if ~tests(k(1),5) % if first bin phase fails, replace signal with noise					y(1)=mean(noise);				end				p=polyfit(bin(k),y,1);				range=bin([ki,kf]);				thresh=-p(2)/p(1);				slope=p(1);				break			end		end		% start over at end of previously attempted range		ki=kf;		if ki~=n			ki=ki+1;		end	endelse % just do regression using score bounds passed by caller	[ ki, kf ] = deal( varargin{ : } )	k=ki:kf;	y=sig(k);	if ~tests(k(1),5) % if first bin phase fails, replace signal with noise		y(1)=mean(noise);	end	p=polyfit(bin(k),y,1);	range=bin([ki,kf]);	thresh=-p(2)/p(1);	slope=p(1);endreturn%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function k=findFirstPoint(ki,n,tests)for k=ki:n-1	% this is first point ( snr, not spike, noise ),	% next is range point( snr, not spike, noise, phase )	if tests(k,7) & tests(k+1,8) 		return	endendk=NaN;%-------------------------------------function k=findRangeExtent(ki,n,tests)for k=ki:n-1	if ~tests(k+1,8)		return % last in series of range points( snr, not spike, noise, phase )	endendk=n;%-------------------------------------function test=testInitialRange(ki,kf,tests)test = any( tests( ki:kf, 3 ) );if( ~test )	s=kf-ki+1;	test=0;	if s>=2		test=tests(kf,9); % final SNR > 3.0		if s==2			test=test & tests(ki,9); % also init SNR > 3.0		end	endend%-------------------------------------function kf=forceMonotonic(ki,kf,tests)for k=ki:kf-1	if ~tests(k+1,6) 		kf=k;		return % last bin where sig g.t. prev bin	endend%-------------------------------------function ki=addRange(ki,tests)while ki~=1	% decrement initial bin until phase or monotonic fails	if ~tests(ki,5) | ~tests(ki,6)		break 	end	ki=ki-1;endif ki~=1 & tests(ki,6) % if still monotonic, decrement once more	ki=ki-1;end