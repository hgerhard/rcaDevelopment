function tSweepMat = SweepMat( tRLSMat )% Convert a 3-D matrix that is NSteps x 6(triad terms) x NSubjects(or NTrials) (usually from call to RLSMat)% to a 2-D matrix that is NSteps x 5 sweep stats (see below) ready for threshold scoring by HybridNewOldScore% Command line usage for debugging would be something like SweepMat( RLSMat )tN = size( tRLSMat, 3 );tRLSMean = nanmean( tRLSMat, 3 );tSr = tRLSMean( :, 1 );tSi = tRLSMean( :, 2 );tN1r = tRLSMean( :, 3 );tN1i = tRLSMean( :, 4 );tN2r = tRLSMean( :, 5 );tN2i = tRLSMean( :, 6 );tVSr = nanvar( squeeze( tRLSMat( :, 1, : ) )' )';tVSi = nanvar( squeeze( tRLSMat( :, 2, : ) )' )';tSweepMat( :, 1 ) = abs( tSr + tSi * i ); % Signal magnitudetSweepMat( :, 2 ) = nanmean( [ abs( tN1r + tN1i * i ) abs( tN2r + tN2i * i ) ], 2 ); % Mean noise magnitudetSweepMat( :, 3 ) = atan2( tSi, tSr ) * 180 / pi; % Signal phase in degreestSweepMat( :, 4 ) = tSweepMat( :, 1 ) ./ mean( tSweepMat( :, 2 ), 1 ); % SNR% PVal is fudged a little to get close to the same result as PowerDIVA and Excel.% Here we use (tN-1) in the numerator of the F-ratio; PowerDIVA and Excel use tN.% Still only accurate to about the 3rd decimal place.tSweepMat( :, 5 ) = fpdf( ( ( tSr .^ 2 + tSi .^ 2 ) * ( tN - 1 ) ) ./ ( tVSr + tVSi ), 2, 2 * tN - 2 );